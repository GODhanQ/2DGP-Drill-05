<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Lecture06_HandlingInputs/move_my_character_with_key.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Lecture06_HandlingInputs/move_my_character_with_key.py" />
              <option name="originalContent" value="from pico2d import *&#10;from sprite_info import Sprite&#10;&#10;# §상하좌우 방향키이를 이용해서 캐릭터를 상하좌우로 이동.&#10;# §IDLE 애니메이션 있어야 함.&#10;# §배경 : TUK_GROUND.png 사용&#10;# §화면 경계면에 다다르면 더 이상 진행하지 않음.&#10;# §소스코드 이름은 move_my_character_with_key.py&#10;&#10;Window_width, Window_height = 1280, 1024&#10;open_canvas(Window_width, Window_height)&#10;&#10;tuk_ground = load_image('TUK_GROUND.png')&#10;character = load_image('animation_sheet.png')&#10;&#10;running = True&#10;mov_vec = [0, 0]&#10;&#10;RIGHT_IDLE = 0&#10;LEFT_IDLE = 1&#10;RIGHT_RUN = 2&#10;LEFT_RUN = 3&#10;WhichAction = RIGHT_IDLE&#10;&#10;right_move, left_move = False, False&#10;x = Window_width // 2&#10;y = Window_height // 2&#10;&#10;def event_handler():&#10;    global running, WhichAction, mov_vec, right_move, left_move&#10;    events = get_events()&#10;    for event in events:&#10;        if event.type == SDL_QUIT:&#10;            running = False&#10;        elif event.type == SDL_KEYDOWN:&#10;            if event.key == SDLK_ESCAPE:&#10;                running = False&#10;            elif event.key == SDLK_RIGHT:&#10;                WhichAction = RIGHT_RUN&#10;                right_move = True&#10;                left_move = False&#10;                mov_vec[0] = 1&#10;            elif event.key == SDLK_LEFT:&#10;                WhichAction = RIGHT_RUN  # 같은 애니메이션을 좌우 반전해서 사용&#10;                right_move = False&#10;                left_move = True&#10;                mov_vec[0] = -1&#10;            elif event.key == SDLK_UP:&#10;                mov_vec[1] = 1&#10;            elif event.key == SDLK_DOWN:&#10;                mov_vec[1] = -1&#10;        elif event.type == SDL_KEYUP:&#10;            if event.key == SDLK_RIGHT:&#10;                WhichAction = RIGHT_IDLE&#10;                right_move = True&#10;                left_move = False&#10;                mov_vec[0] = 0&#10;            elif event.key == SDLK_LEFT:&#10;                WhichAction = RIGHT_IDLE&#10;                right_move = False&#10;                left_move = True&#10;                mov_vec[0] = 0&#10;            elif event.key == SDLK_UP:&#10;                mov_vec[1] = 0&#10;            elif event.key == SDLK_DOWN:&#10;                mov_vec[1] = 0&#10;&#10;def Draw_character():&#10;    global frame&#10;    left, bottom, width, height = Sprite[WhichAction][frame]&#10;    &#10;    if left_move:&#10;        # 좌측 이동 시 이미지를 좌우 반전&#10;        character.clip_composite_draw(&#10;            left, bottom, width, height,&#10;            0, 'h',  # 'h'는 수평 반전&#10;            x, y, width, height&#10;        )&#10;    else:&#10;        # 우측 이동 또는 기본 상태&#10;        character.clip_draw(left, bottom, width, height, x, y)&#10;&#10;frame = 0&#10;while running:&#10;    clear_canvas()&#10;    tuk_ground.draw(Window_width // 2, Window_height // 2)&#10;    Draw_character()&#10;    update_canvas()&#10;&#10;    event_handler()&#10;    if not running:&#10;        break&#10;    &#10;    # 이동 처리 (벡터의 각 요소에 속도를 곱함)&#10;    new_x = x + mov_vec[0] * 5&#10;    new_y = y + mov_vec[1] * 5&#10;    &#10;    # 경계 체크&#10;    if 0 &lt;= new_x &lt;= Window_width:&#10;        x = new_x&#10;    if 0 &lt;= new_y &lt;= Window_height:&#10;        y = new_y&#10;&#10;    frame = (frame + 1) % 8&#10;    delay(0.1)&#10;&#10;close_canvas()" />
              <option name="updatedContent" value="from pico2d import *&#10;from sprite_info import Sprite&#10;&#10;# §상하좌우 방향키이를 이용해서 캐릭터를 상하좌우로 이동.&#10;# §IDLE 애니메이션 있어야 함.&#10;# §배경 : TUK_GROUND.png 사용&#10;# §화면 경계면에 다다르면 더 이상 진행하지 않음.&#10;# §소스코드 이름은 move_my_character_with_key.py&#10;&#10;Window_width, Window_height = 1280, 1024&#10;open_canvas(Window_width, Window_height)&#10;&#10;tuk_ground = load_image('TUK_GROUND.png')&#10;character = load_image('animation_sheet.png')&#10;&#10;running = True&#10;mov_vec = [0, 0]&#10;&#10;RIGHT_IDLE = 0&#10;LEFT_IDLE = 1&#10;RIGHT_RUN = 2&#10;LEFT_RUN = 3&#10;WhichAction = RIGHT_IDLE&#10;&#10;right_move, left_move = False, False&#10;x = Window_width // 2&#10;y = Window_height // 2&#10;&#10;def event_handler():&#10;    global running, WhichAction, mov_vec, right_move, left_move&#10;    events = get_events()&#10;    for event in events:&#10;        if event.type == SDL_QUIT:&#10;            running = False&#10;        elif event.type == SDL_KEYDOWN:&#10;            if event.key == SDLK_ESCAPE:&#10;                running = False&#10;            elif event.key == SDLK_RIGHT:&#10;                WhichAction = RIGHT_RUN&#10;                right_move = True&#10;                left_move = False&#10;                mov_vec[0] = 1&#10;            elif event.key == SDLK_LEFT:&#10;                WhichAction = RIGHT_RUN  # 같은 애니메이션을 좌우 반전해서 사용&#10;                right_move = False&#10;                left_move = True&#10;                mov_vec[0] = -1&#10;            elif event.key == SDLK_UP:&#10;                mov_vec[1] = 1&#10;            elif event.key == SDLK_DOWN:&#10;                mov_vec[1] = -1&#10;        elif event.type == SDL_KEYUP:&#10;            if event.key == SDLK_RIGHT:&#10;                WhichAction = RIGHT_IDLE&#10;                right_move = True&#10;                left_move = False&#10;                mov_vec[0] = 0&#10;            elif event.key == SDLK_LEFT:&#10;                WhichAction = RIGHT_IDLE&#10;                right_move = False&#10;                left_move = True&#10;                mov_vec[0] = 0&#10;            elif event.key == SDLK_UP:&#10;                mov_vec[1] = 0&#10;            elif event.key == SDLK_DOWN:&#10;                mov_vec[1] = 0&#10;&#10;def Draw_character():&#10;    global frame&#10;    left, bottom, width, height = Sprite[WhichAction][frame]&#10;    &#10;    if left_move:&#10;        # 좌측 이동 시 이미지를 좌우 반전&#10;        character.clip_composite_draw(&#10;            left, bottom, width, height,&#10;            0, 'h',  # 'h'는 수평 반전&#10;            x, y, width, height&#10;        )&#10;    else:&#10;        # 우측 이동 또는 기본 상태&#10;        character.clip_draw(left, bottom, width, height, x, y)&#10;&#10;frame = 0&#10;while running:&#10;    clear_canvas()&#10;    tuk_ground.draw(Window_width // 2, Window_height // 2)&#10;    Draw_character()&#10;    update_canvas()&#10;&#10;    event_handler()&#10;    if not running:&#10;        break&#10;    &#10;    # 이동 처리 (벡터의 각 요소에 속도를 곱함)&#10;    new_x = x + mov_vec[0] * 5&#10;    new_y = y + mov_vec[1] * 5&#10;    &#10;    # 경계 체크&#10;    if 0 &lt;= new_x &lt;= Window_width:&#10;        x = new_x&#10;    if 0 &lt;= new_y &lt;= Window_height:&#10;        y = new_y&#10;&#10;    frame = (frame + 1) % 8&#10;    delay(0.1)&#10;&#10;close_canvas()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>